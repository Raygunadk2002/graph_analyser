<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structural Movement Graph Analyser</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <script src="https://cdn.plot.ly/plotly-2.32.0.min.js"></script>
    <script src="https://unpkg.com/axios/dist/axios.min.js"></script>
</head>
<body class="bg-gray-100 min-h-screen">
    <!-- Navigation Bar -->
    <nav class="bg-white shadow-lg">
        <div class="container mx-auto px-4">
            <div class="flex justify-between items-center py-4">
                <div class="flex items-center">
                    <a href="/dashboard" class="text-xl font-bold text-gray-800">Structural Movement Analysis</a>
                </div>
                <div class="flex space-x-4">
                    <a href="/dashboard" class="text-gray-600 hover:text-blue-600 px-3 py-2 rounded-md text-sm font-medium">Basic Analysis</a>
                    <a href="/seasonal" class="text-gray-600 hover:text-blue-600 px-3 py-2 rounded-md text-sm font-medium">Seasonal Analysis</a>
                    <a href="/advanced" class="text-gray-600 hover:text-blue-600 px-3 py-2 rounded-md text-sm font-medium">Advanced Analysis</a>
                    <a href="/docs" class="text-gray-600 hover:text-blue-600 px-3 py-2 rounded-md text-sm font-medium">API Docs</a>
                </div>
            </div>
        </div>
    </nav>

    <div class="container mx-auto px-4 py-8">
        <h1 class="text-3xl font-bold mb-8">Basic Analysis</h1>

        <!-- Authentication Section -->

        <!-- Project Section -->
        <div id="project-section" class="mb-6 hidden">
            <label class="block text-gray-700 font-medium mb-2">Select Project</label>
            <select id="project-select" class="border rounded px-2 py-1 mb-2"></select>
            <div class="flex space-x-2">
                <input type="text" id="new-project-name" class="border px-2 py-1" placeholder="New project name">
                <button id="create-project" class="bg-blue-600 text-white px-3 py-1 rounded">Create</button>
            </div>
        </div>
        
        <!-- File Upload Section -->
        <div class="mb-8">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center">
                <input type="file" multiple id="file-input" class="hidden" accept=".csv,.xlsx,.xls">
                <label for="file-input" class="cursor-pointer">
                    <div class="text-gray-600 mb-4">
                        <svg class="mx-auto h-12 w-12" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"/>
                        </svg>
                    </div>
                    <p class="text-lg font-medium text-gray-700">Click to upload or drag and drop</p>
                    <p class="text-sm text-gray-500 mt-2">CSV, XLSX, or XLS files up to 10MB</p>
                </label>
            </div>
            <div id="upload-progress" class="hidden mt-4">
                <div class="w-full bg-gray-200 rounded-full h-2.5">
                    <div class="bg-blue-600 h-2.5 rounded-full" style="width: 0%"></div>
                </div>
                <div id="upload-status" class="text-center mt-2 text-gray-600"></div>
            </div>
        </div>
        
        <!-- Postcode Input for Rainfall -->
        <div class="mb-6">
            <label for="postcode-input" class="block text-gray-700 font-medium mb-2">Enter UK Postcode for Rainfall Data:</label>
            <div class="flex space-x-2">
                <input type="text" id="postcode-input" class="border border-gray-300 rounded-lg px-4 py-2 w-48" placeholder="e.g. SW1A 1AA">
                <button id="fetch-rainfall" class="bg-blue-600 text-white px-4 py-2 rounded-lg hover:bg-blue-700 transition-colors">Get Rainfall</button>
            </div>
            <div id="rainfall-status" class="mt-2 text-gray-600"></div>
        </div>
        
        <!-- Column Mapping -->
        <div id="column-mapping" class="mb-6 hidden">
            <label class="block text-gray-700 font-medium mb-2">Map columns:</label>
            <div class="grid grid-cols-1 md:grid-cols-2 gap-4" id="column-mapping-fields"></div>
        </div>
        
        <!-- Basic Graph Section -->
        <div id="basic-graph-section" class="mb-6">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Sensor Data & Rainfall</h2>
            <div id="basic-graph-container" class="w-full h-96 mb-8"></div>
            <div id="correlation-section" class="bg-gray-50 p-4 rounded-lg">
                <h3 class="font-semibold text-lg mb-2">Rainfall-Movement Correlation</h3>
                <div id="correlation-info" class="text-gray-700"></div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="results" class="mt-8">
            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Analysis Results</h2>
                <div id="analysis-summary" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>

            <div class="mb-6">
                <h2 class="text-2xl font-semibold text-gray-800 mb-4">Graphs</h2>
                <div id="graphs-container" class="space-y-6"></div>
            </div>

            <div class="flex justify-end space-x-4">
                <button id="generate-report" class="bg-green-600 text-white px-6 py-2 rounded-lg hover:bg-green-700 transition-colors">
                    Generate Report
                </button>
            </div>
        </div>
    </div>

    <script>
        // Add initialization check
        document.addEventListener('DOMContentLoaded', function() {
            if (!localStorage.getItem('authToken')) {
                window.location.href = '/login';
                return;
            }
            console.log('DOM fully loaded and parsed');
            initializeApp();
        });

        // Main initialization function
        function initializeApp() {
            try {
                console.log('Initializing application...');

                // Setup axios authorization header
                axios.interceptors.request.use(config => {
                    const token = localStorage.getItem('authToken');
                    if (token) {
                        config.headers['Authorization'] = `Bearer ${token}`;
                    }
                    return config;
                });

                // Setup auth form handlers
                initializeAuth();

                // Initialize file upload
                initializeFileUpload();

                // Test server connection
                testServer();

                console.log('Application initialized successfully');
            } catch (error) {
                console.error('Error initializing application:', error);
                alert('There was an error loading the application. Please check the console for details.');
            }
        }
        
        // Initialize authentication and project management
        function initializeAuth() {
            const signupForm = document.getElementById('signup-form');
            const loginForm = document.getElementById('login-form');
            const authStatus = document.getElementById('auth-status');
            const projectSection = document.getElementById('project-section');
            const projectSelect = document.getElementById('project-select');
            const createProjectBtn = document.getElementById('create-project');
            const newProjectName = document.getElementById('new-project-name');

            async function loadProjects() {
                try {
                    const res = await axios.get('/projects');
                    projectSelect.innerHTML = '';
                    res.data.projects.forEach(p => {
                        const opt = document.createElement('option');
                        opt.value = p.id;
                        opt.textContent = p.name;
                        projectSelect.appendChild(opt);
                    });
                    projectSection.classList.remove('hidden');
                } catch (err) {
                    console.error('Error loading projects', err);
                    if (err.response && err.response.status === 401) {
                        localStorage.removeItem('authToken');
                        window.location.href = '/login';
                    }
                }
            }

            if (signupForm) {
                signupForm.addEventListener('submit', async e => {
                    e.preventDefault();
                    try {
                        await axios.post('/signup', {
                            username: document.getElementById('signup-username').value,
                            password: document.getElementById('signup-password').value
                        });
                        authStatus.textContent = 'Signup successful';
                        authStatus.className = 'text-green-600 text-sm';
                    } catch (err) {
                        authStatus.textContent = 'Signup error: ' + (err.response?.data?.detail || err.message);
                        authStatus.className = 'text-red-600 text-sm';
                    }
                });
            }

            if (loginForm) {
                loginForm.addEventListener('submit', async e => {
                    e.preventDefault();
                    try {
                        const res = await axios.post('/login', {
                            username: document.getElementById('login-username').value,
                            password: document.getElementById('login-password').value
                        });
                        localStorage.setItem('authToken', res.data.token);
                        authStatus.textContent = 'Logged in';
                        authStatus.className = 'text-green-600 text-sm';
                        loadProjects();
                    } catch (err) {
                        authStatus.textContent = 'Login error: ' + (err.response?.data?.detail || err.message);
                        authStatus.className = 'text-red-600 text-sm';
                    }
                });
            }

            if (createProjectBtn) {
                createProjectBtn.addEventListener('click', async e => {
                    e.preventDefault();
                    try {
                        const name = newProjectName.value.trim();
                        if (!name) return;
                        await axios.post('/projects', { name });
                        newProjectName.value = '';
                        loadProjects();
                    } catch (err) {
                        console.error('Project creation error', err);
                    }
                });
            }

            if (localStorage.getItem('authToken')) {
                loadProjects();
            }
        }

        // Initialize file upload handlers
        function initializeFileUpload() {
            // Get all the required DOM elements
            const fileInput = document.getElementById('file-input');
            const uploadProgress = document.getElementById('upload-progress');
            const uploadStatus = document.getElementById('upload-status');
            const analysisSummary = document.getElementById('analysis-summary');
            const graphsContainer = document.getElementById('graphs-container');
            const sensorSelect = document.getElementById('sensor-select');
            const columnMappingSection = document.getElementById('column-mapping');
            const columnMappingFields = document.getElementById('column-mapping-fields');
            const rainfallStatus = document.getElementById('rainfall-status');
            const postcodeInput = document.getElementById('postcode-input');
            const fetchRainfallBtn = document.getElementById('fetch-rainfall');
            const generateReportBtn = document.getElementById('generate-report');
            
            // Check that required elements exist
            if (!fileInput) {
                console.error('File input element not found');
                return;
            }
            
            // Fields to map
            const requiredFields = [
                { key: 'time', label: 'Time/Date' },
                { key: 'x', label: 'X Axis' },
                { key: 'y', label: 'Y Axis' },
                { key: 'z', label: 'Z Axis' },
                { key: 't', label: 'Temperature' }
            ];
            
            // Global variables
            window.detectedColumns = [];
            window.columnMapping = {};
            window.uploadedData = null;
            window.rainfallData = null;
            
            // Test server connection
            if (fileInput) {
                fileInput.addEventListener('change', handleFileUpload);
            }
            
            // Initialize rainfall data fetching
            if (fetchRainfallBtn && postcodeInput) {
                fetchRainfallBtn.addEventListener('click', handleRainfallFetch);
            }
            
            // Initialize report generation
            if (generateReportBtn) {
                generateReportBtn.addEventListener('click', handleReportGeneration);
            }
            
            // Update UI based on file selection
            if (fileInput) {
                fileInput.addEventListener('change', updateUI);
            }
            
            // File upload handler
            async function handleFileUpload(e) {
                const files = Array.from(e.target.files || []);
                if (!files.length) return;

                for (const file of files) {

                // Reset data
                window.uploadedData = null;
                
                // Show progress bar and status
                if (uploadProgress) {
                    uploadProgress.classList.remove('hidden');
                    const progressBar = uploadProgress.querySelector('.bg-blue-600');
                    if (progressBar) progressBar.style.width = '0%';
                }
                
                if (uploadStatus) {
                    uploadStatus.textContent = 'Uploading file...';
                    uploadStatus.className = 'text-center mt-2 text-blue-600';
                }

                try {
                    const formData = new FormData();
                    formData.append('file', file);
                    const projectSelect = document.getElementById('project-select');
                    if (projectSelect) {
                        formData.append('project_id', projectSelect.value);
                    }

                    if (uploadStatus) uploadStatus.textContent = 'Processing file...';

                    console.log('Uploading file:', file.name);
                    const response = await axios.post('/upload', formData, {
                        headers: {
                            'Content-Type': 'multipart/form-data'
                        },
                        onUploadProgress: function(progressEvent) {
                            const percentCompleted = Math.round((progressEvent.loaded * 100) / progressEvent.total);
                            console.log('Upload progress:', percentCompleted);
                            if (uploadProgress) {
                                const progressBar = uploadProgress.querySelector('.bg-blue-600');
                                if (progressBar) progressBar.style.width = percentCompleted + '%';
                            }
                        }
                    });

                    console.log('Upload response:', response.data);
                    
                    if (response.data.status === 'success') {
                        if (uploadStatus) {
                            uploadStatus.textContent = 'File uploaded successfully!';
                            uploadStatus.className = 'text-center mt-2 text-green-600';
                        }
                        window.uploadedData = response.data.data;
                        
                        // Clear any previously plotted graph and sensor dropdown to avoid showing stale data
                        const basicGraphContainer = document.getElementById('basic-graph-container');
                        if (basicGraphContainer) {
                            Plotly.purge(basicGraphContainer);
                        }
                        if (sensorSelect) {
                            sensorSelect.innerHTML = '';
                        }

                        // Hide the basic graph section until new analysis is completed
                        const graphSection = document.getElementById('basic-graph-section');
                        if (graphSection) {
                            graphSection.classList.add('hidden');
                        }

                        window.uploadedData.filename = file.name;
                        window.detectedColumns = window.uploadedData.columns || [];
                        
                        // Enable postcode input and fetch button
                        const postcodeInput = document.getElementById('postcode-input');
                        const fetchRainfallBtn = document.getElementById('fetch-rainfall');
                        if (postcodeInput) postcodeInput.disabled = false;
                        if (fetchRainfallBtn) fetchRainfallBtn.disabled = false;
                        
                        // Show column mapping
                        showColumnMapping();
                        
                        // Update UI state
                        updateUI();
                    } else {
                        throw new Error(response.data.detail || 'Unexpected response format');
                    }
                } catch (error) {
                    console.error('Upload error:', error);
                    const errorMessage = error.response?.data?.detail || error.message;
                    if (uploadStatus) {
                        uploadStatus.textContent = 'Error: ' + errorMessage;
                        uploadStatus.className = 'text-center mt-2 text-red-600';
                    }
                }
                }
            }
            
            // Function to show column mapping UI
            function showColumnMapping() {
                if (!columnMappingSection || !columnMappingFields) {
                    console.error('Column mapping elements not found');
                    return;
                }
                
                if (!window.detectedColumns || window.detectedColumns.length === 0) {
                    console.error('No columns detected in uploaded file');
                    return;
                }
                
                // Reset mapping UI
                columnMappingFields.innerHTML = '';
                window.columnMapping = {};
                
                // Show the column mapping section
                columnMappingSection.classList.remove('hidden');
                
                // Create fields for each required column
                requiredFields.forEach(field => {
                    const fieldContainer = document.createElement('div');
                    fieldContainer.className = 'mb-4';
                    
                    const label = document.createElement('label');
                    label.className = 'block text-gray-700 font-medium mb-2';
                    label.textContent = `Select column for ${field.label}:`;
                    
                    const select = document.createElement('select');
                    select.className = 'border border-gray-300 rounded-lg px-4 py-2 w-full';
                    select.id = `mapping-${field.key}`;
                    
                    // Add empty option
                    const emptyOption = document.createElement('option');
                    emptyOption.value = '';
                    emptyOption.textContent = '-- Select column --';
                    select.appendChild(emptyOption);
                    
                    // Add options for each detected column
                    window.detectedColumns.forEach(column => {
                        const option = document.createElement('option');
                        option.value = column;
                        option.textContent = column;
                        
                        // Auto-select if column name matches
                        if (field.key === 'time' && column.toLowerCase() === 'date') {
                            option.selected = true;
                            window.columnMapping[field.key] = column;
                        } else if (field.key === 't' && (column.toLowerCase().includes('temp') || column === 'T')) {
                            option.selected = true;
                            window.columnMapping[field.key] = column;
                            console.log('Auto-selected temperature column:', column);
                        } else if (column.toLowerCase().includes(field.key.toLowerCase())) {
                            option.selected = true;
                            window.columnMapping[field.key] = column;
                        }
                        
                        select.appendChild(option);
                    });
                    
                    // Add event listener for selection change
                    select.addEventListener('change', (e) => {
                        const selectedValue = e.target.value;
                        if (selectedValue) {
                            window.columnMapping[field.key] = selectedValue;
                            console.log(`Updated mapping for ${field.key}:`, selectedValue);
                        } else {
                            delete window.columnMapping[field.key];
                            console.log(`Removed mapping for ${field.key}`);
                        }
                        console.log('Current mapping:', window.columnMapping);
                        updateAnalyzeButton();
                    });
                    
                    fieldContainer.appendChild(label);
                    fieldContainer.appendChild(select);
                    columnMappingFields.appendChild(fieldContainer);
                });
                
                // Add analyze button
                const buttonContainer = document.createElement('div');
                buttonContainer.className = 'mt-4';
                
                const analyzeButton = document.createElement('button');
                analyzeButton.id = 'analyze-button';
                analyzeButton.className = 'bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors';
                analyzeButton.textContent = 'Analyze Data';
                analyzeButton.addEventListener('click', handleAnalyze);
                
                buttonContainer.appendChild(analyzeButton);
                columnMappingFields.appendChild(buttonContainer);
                
                updateAnalyzeButton();
                
                // Log initial mapping
                console.log('Initial column mapping:', window.columnMapping);
            }
            
            // Function to update analyze button state
            function updateAnalyzeButton() {
                const analyzeButton = document.getElementById('analyze-button');
                if (!analyzeButton) return;
                
                // Time field is required, at least one of X/Y/Z is required
                const hasTimeField = window.columnMapping && window.columnMapping.time;
                const hasAxisField = window.columnMapping && (window.columnMapping.x || window.columnMapping.y || window.columnMapping.z);
                
                analyzeButton.disabled = !(hasTimeField && hasAxisField);
                analyzeButton.className = analyzeButton.disabled 
                    ? 'bg-gray-400 cursor-not-allowed text-white px-6 py-2 rounded-lg'
                    : 'bg-blue-600 text-white px-6 py-2 rounded-lg hover:bg-blue-700 transition-colors';
            }
            
            // Function to handle analyze button click
            async function handleAnalyze() {
                const uploadStatus = document.getElementById('upload-status');
                const postcodeInput = document.getElementById('postcode-input');
                const fetchRainfallBtn = document.getElementById('fetch-rainfall');
                
                if (!window.uploadedData || !window.uploadedData.file_id) {
                    if (uploadStatus) {
                        uploadStatus.textContent = 'Please upload a file first.';
                        uploadStatus.className = 'text-center mt-2 text-red-600';
                    }
                    return;
                }
                
                try {
                    if (uploadStatus) {
                        uploadStatus.textContent = 'Analyzing data...';
                        uploadStatus.className = 'text-center mt-2 text-blue-600';
                    }
                    
                    // Disable inputs during analysis
                    if (postcodeInput) postcodeInput.disabled = true;
                    if (fetchRainfallBtn) fetchRainfallBtn.disabled = true;
                    
                    // Create form data
                    const formData = new FormData();
                    
                    // Add the mapping and file_id
                    formData.append('mapping', JSON.stringify(window.columnMapping));
                    formData.append('file_id', window.uploadedData.file_id);
                    
                    // Log the data being sent
                    console.log('Sending mapping:', window.columnMapping);
                    console.log('File ID:', window.uploadedData.file_id);
                    
                    const response = await axios.post('/analyse', formData);
                    
                    if (response.data && response.data.status === 'success') {
                        // Clear previous data completely to prevent phantom data
                        window.uploadedData = response.data.data;
                        
                        // Log the response data for debugging
                        console.log('Analysis response:', response.data);
                        console.log('Plot data:', response.data.data.plot_data);
                        
                        // Show success message
                        if (uploadStatus) {
                            uploadStatus.textContent = 'Analysis complete!';
                            uploadStatus.className = 'text-center mt-2 text-green-600';
                        }
                        
                        // Update the UI with the analysis results
                        updateUIWithResults();
                        
                        // Enable the postcode input and fetch button
                        if (postcodeInput) postcodeInput.disabled = false;
                        if (fetchRainfallBtn) fetchRainfallBtn.disabled = false;
                        
                        // Show the basic graph section
                        const basicGraphSection = document.getElementById('basic-graph-section');
                        if (basicGraphSection) {
                            basicGraphSection.classList.remove('hidden');
                        }
                        
                        // Update the graph
                        updateGraph(response.data.data.plot_data);
                    } else {
                        throw new Error(response.data.detail || 'Unexpected response format');
                    }
                } catch (error) {
                    console.error('Analysis error:', error);
                    if (uploadStatus) {
                        uploadStatus.textContent = `Error: ${error.message}`;
                        uploadStatus.className = 'text-center mt-2 text-red-600';
                    }
                    
                    // Enable inputs on error
                    if (postcodeInput) postcodeInput.disabled = false;
                    if (fetchRainfallBtn) fetchRainfallBtn.disabled = false;
                }
            }
            
            // Function to update UI with analysis results
            function updateUIWithResults() {
                // Store all available sensors for reference in global variable
                window.availableSensors = Object.keys(window.uploadedData.plot_data || {});
                console.log('Available sensors:', window.availableSensors);
                console.log('Plot data:', window.uploadedData.plot_data);
                
                // Update graph with all sensor data
                updateGraph(window.uploadedData.plot_data);
                
                // Show the basic graph section and tab
                document.getElementById('basic-graph-section')?.classList.remove('hidden');
                document.getElementById('tab-basic')?.click();
            }
            
            // Function to update the graph with the analysis results
            function updateGraph(data) {
                console.log('Updating graph with data:', data);
                console.log('Data keys:', Object.keys(data));
                
                // Check if data is valid
                if (!data || typeof data !== 'object') {
                    console.error('Invalid data provided to updateGraph:', data);
                    return;
                }
                
                // Create array for traces
                const traces = [];
                const colors = {
                    'X': '#1f77b4',  // blue
                    'Y': '#ff7f0e',  // orange
                    'T': '#2ca02c',  // green
                    'Z': '#d62728'   // red
                };
                
                // Process each sensor's data
                Object.entries(data).forEach(([sensor, sensorData]) => {
                    console.log(`Processing ${sensor} data:`, sensorData);
                    
                    if (!sensorData || !sensorData.time || !sensorData.values) {
                        console.log(`Skipping ${sensor} - invalid data`);
                        return;
                    }
                    
                    // Convert string values to numbers and filter out invalid values
                    const validData = sensorData.time.map((time, index) => {
                        if (!time || !sensorData.values[index]) {
                            return null;
                        }
                        const value = parseFloat(sensorData.values[index]);
                        return isNaN(value) ? null : { time, value };
                    }).filter(item => item !== null);
                    
                    if (validData.length === 0) {
                        console.log(`Skipping ${sensor} - no valid data points`);
                        return;
                    }
                    
                    console.log(`Adding trace for ${sensor} with ${validData.length} valid points`);
                    console.log(`Sample data for ${sensor}:`, validData.slice(0, 3));
                    
                    // Create trace for this sensor
                    const trace = {
                        x: validData.map(d => d.time),
                        y: validData.map(d => d.value),
                        type: 'scatter',
                        mode: 'lines',
                        name: sensor,
                        line: {
                            color: colors[sensor] || '#000000',
                            width: 2
                        }
                    };
                    
                    // Put temperature on its own axis
                    if (sensor === 'T') {
                        trace.yaxis = 'y2';
                        console.log('Setting temperature trace to y2 axis');
                    }
                    
                    traces.push(trace);
                });
                
                // Only create the graph if we have valid traces
                if (traces.length === 0) {
                    console.error('No valid traces to plot');
                    return;
                }
                
                console.log('Final traces:', traces);
                
                // Create layout with dual axes
                const layout = {
                    title: 'Sensor Data Over Time',
                    xaxis: {
                        title: 'Time',
                        showgrid: true,
                        gridcolor: '#E5E7EB'
                    },
                    yaxis: {
                        title: 'Movement (mm)',
                        showgrid: true,
                        gridcolor: '#E5E7EB'
                    },
                    yaxis2: {
                        title: 'Temperature (°C)',
                        overlaying: 'y',
                        side: 'right',
                        showgrid: false,
                        titlefont: { color: colors['T'] },
                        tickfont: { color: colors['T'] }
                    },
                    plot_bgcolor: '#FFFFFF',
                    paper_bgcolor: '#FFFFFF',
                    font: {
                        family: 'Arial, sans-serif',
                        size: 12,
                        color: '#1F2937'
                    },
                    margin: {
                        l: 50,
                        r: 50,
                        t: 50,
                        b: 50
                    },
                    showlegend: true,
                    legend: {
                        x: 1.1,
                        y: 1,
                        bgcolor: '#FFFFFF',
                        bordercolor: '#E5E7EB',
                        borderwidth: 1
                    }
                };
                
                // Create the graph
                Plotly.newPlot('basic-graph-container', traces, layout);
            }
            
            // Rainfall fetching handler
            async function handleRainfallFetch() {
                const postcode = postcodeInput.value.trim();
                if (!postcode) {
                    if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-red-600">Please enter a UK postcode</span>';
                    return;
                }
                
                try {
                    // Show loading message
                    if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-blue-600">Converting postcode to coordinates...</span>';
                    
                    // Step 1: Convert postcode to lat/lon
                    const geocodeResponse = await axios.post('/geocode', null, {
                        params: { postcode: postcode }
                    });
                    
                    if (geocodeResponse.data.error) {
                        if (rainfallStatus) rainfallStatus.innerHTML = `<span class="text-red-600">Error: ${geocodeResponse.data.error}</span>`;
                        return;
                    }
                    
                    const { latitude, longitude } = geocodeResponse.data;
                    if (!latitude || !longitude) {
                        if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-red-600">Could not find coordinates for this postcode</span>';
                        return;
                    }
                    
                    // Step 2: Get date range from sensor data
                    if (!window.uploadedData || !window.uploadedData.plot_data) {
                        if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-red-600">Please upload sensor data first</span>';
                        return;
                    }
                    
                    // Get the first available sensor data with time information
                    const availableSensors = Object.keys(window.uploadedData.plot_data || {});
                    if (availableSensors.length === 0) {
                        if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-red-600">No valid sensor data found</span>';
                        return;
                    }
                    
                    const selectedColumn = availableSensors[0]; // Use first available sensor
                    
                    // Get time range from the data
                    const timeData = window.uploadedData.plot_data[selectedColumn].time;
                    if (!timeData || !Array.isArray(timeData) || timeData.length < 2) {
                        if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-red-600">No valid time data found</span>';
                        return;
                    }
                    
                    // Format dates for API call (YYYY-MM-DD)
                    const startDate = timeData[0].split('T')[0];
                    const endDate = timeData[timeData.length - 1].split('T')[0];
                    
                    if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-blue-600">Fetching rainfall data...</span>';
                    
                    // Step 3: Get rainfall data
                    const rainfallResponse = await axios.post('/rainfall', null, {
                        params: { 
                            lat: latitude, 
                            lon: longitude,
                            start_date: startDate,
                            end_date: endDate
                        }
                    });
                    
                    // Log the full rainfall response for debugging
                    console.log('Full rainfall response:', rainfallResponse.data);
                    
                    if (rainfallResponse.data.error) {
                        if (rainfallStatus) rainfallStatus.innerHTML = `<span class="text-red-600">Error: ${rainfallResponse.data.error}</span>`;
                        return;
                    }
                    
                    // Extract dates and values from the response
                    const dates = rainfallResponse.data.dates;
                    const values = rainfallResponse.data.rainfall;
                    
                    console.log('Extracted rainfall data:', { dates, values });
                    
                    if (!Array.isArray(dates) || !Array.isArray(values) || dates.length === 0 || values.length === 0) {
                        console.error('Empty or invalid rainfall data:', { dates, values });
                        if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-red-600">No rainfall data available for this period</span>';
                        return;
                    }
                    
                    // Store the rainfall data
                    window.rainfallData = {
                        dates: dates,
                        values: values.map(v => {
                            const num = Number(v);
                            return isNaN(num) ? 0 : num; // Convert to numbers, use 0 for invalid values
                        })
                    };
                    
                    if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-green-600">Rainfall data loaded successfully!</span>';
                    
                    // Update the graph to include rainfall data
                    updateGraphWithRainfall();
                    
                    // Calculate and show the correlation
                    calculateRainfallCorrelation();
                    
                } catch (error) {
                    console.error('Error fetching rainfall data:', error);
                    if (rainfallStatus) {
                        const errorMsg = error.response?.data?.error || error.response?.data?.detail || error.message;
                        rainfallStatus.innerHTML = `<span class="text-red-600">Error: ${errorMsg}</span>`;
                    }
                }
            }
            
            // Report generation handler
            async function handleReportGeneration() {
                try {
                    const response = await axios.post('/generate-report');
                    alert('Report generated successfully!');
                } catch (error) {
                    alert('Error generating report: ' + (error.response?.data?.detail || error.message));
                }
            }
            
            // Function to update graph with rainfall data
            function updateGraphWithRainfall() {
                const basicGraphContainer = document.getElementById('basic-graph-container');
                if (!basicGraphContainer || !window.uploadedData || !window.uploadedData.plot_data || !window.rainfallData) {
                    console.error("Missing elements for rainfall graph update");
                    return;
                }
                
                // Get the existing sensor traces
                const existingTraces = basicGraphContainer.data || [];
                if (existingTraces.length === 0) {
                    console.error("No existing traces to add rainfall data to");
                    return;
                }
                
                // Create rainfall trace
                const rainfallTrace = {
                    x: window.rainfallData.dates,
                    y: window.rainfallData.values,
                    type: 'bar',
                    name: 'Rainfall',
                    marker: { color: 'rgba(0, 128, 255, 0.5)' },
                    yaxis: 'y2'
                };
                
                // Create temperature trace if available
                let temperatureTrace = null;
                if (window.uploadedData.plot_data['T']) {
                    temperatureTrace = {
                        x: window.uploadedData.plot_data['T'].time,
                        y: window.uploadedData.plot_data['T'].values,
                        type: 'scatter',
                        mode: 'lines+markers',
                        name: 'Temperature',
                        line: { color: 'rgb(255, 128, 0)', width: 2 },
                        marker: { size: 4 },
                        yaxis: 'y2'
                    };
                }
                
                // Include all existing traces plus the rainfall and temperature traces
                const allTraces = [...existingTraces];
                if (temperatureTrace) {
                    allTraces.push(temperatureTrace);
                }
                allTraces.push(rainfallTrace);
                
                // Create updated layout with dual axes
                const layout = {
                    title: `Sensor Data with Rainfall and Temperature (${window.uploadedData?.filename || 'dataset'})`,
                    xaxis: {
                        title: 'Date/Time',
                        tickformat: '%Y-%m-%d'
                    },
                    yaxis: {
                        title: 'Sensor Value',
                        autorange: true
                    },
                    yaxis2: {
                        title: 'Rainfall (mm) / Temperature (°C)',
                        titlefont: { color: 'rgb(0, 128, 255)' },
                        tickfont: { color: 'rgb(0, 128, 255)' },
                        overlaying: 'y',
                        side: 'right',
                        autorange: true
                    },
                    margin: { t: 40 },
                    showlegend: true,
                    legend: {
                        orientation: 'h',
                        y: -0.2
                    }
                };
                
                // Plot the graph with all traces including rainfall and temperature
                Plotly.newPlot(basicGraphContainer, allTraces, layout, {responsive: true});
                
                console.log("Graph updated with rainfall and temperature data");
            }
            
            // Function to calculate and display rainfall correlation
            function calculateRainfallCorrelation() {
                if (!uploadedData || !uploadedData.plot_data || !window.rainfallData) {
                    console.error("Missing data for correlation calculation");
                    return;
                }
                
                const correlationInfo = document.getElementById('correlation-info');
                if (!correlationInfo) return;
                
                // Clear previous correlation information
                correlationInfo.innerHTML = '';
                
                // Create correlation data for each sensor
                const sensors = Object.keys(uploadedData.plot_data).filter(s => ['X', 'Y', 'T'].includes(s));
                if (sensors.length === 0) {
                    correlationInfo.innerHTML = `<p class="text-yellow-600">No X, Y, or T sensor data found for correlation.</p>`;
                    return;
                }
                
                const rainfallDates = window.rainfallData.dates;
                
                // Calculate correlation for each sensor
                let correlationHTML = `<h3 class="text-lg font-semibold mb-2">Rainfall Correlation Results</h3>`;
                let hasSufficientData = false;
                
                for (const sensorName of sensors) {
                    if (!uploadedData.plot_data[sensorName]) continue;
                    
                    const sensorValues = uploadedData.plot_data[sensorName].values;
                    const sensorDates = uploadedData.plot_data[sensorName].time.map(t => t.split('T')[0]);
                    
                    console.log(`Calculating correlation between ${sensorName} and rainfall`);
                    console.log(`Sensor dates: ${sensorDates.length}, Rainfall dates: ${rainfallDates.length}`);
                    
                    // Match dates between sensor and rainfall data
                    const matchedData = {
                        sensor: [],
                        rainfall: []
                    };
                    
                    // Match dates that are the same in both datasets
                    for (let i = 0; i < sensorDates.length; i++) {
                        const date = sensorDates[i];
                        const rainfallIdx = rainfallDates.indexOf(date);
                        
                        if (rainfallIdx !== -1) {
                            const sensorVal = Number(sensorValues[i]);
                            if (!isNaN(sensorVal)) {
                                matchedData.sensor.push(sensorVal);
                                matchedData.rainfall.push(window.rainfallData.values[rainfallIdx]);
                            }
                        }
                    }
                    
                    if (matchedData.sensor.length < 5) {
                        correlationHTML += `<p class="text-yellow-600 mb-2">Not enough matching dates for ${sensorName} correlation (found ${matchedData.sensor.length}).</p>`;
                        continue;
                    }
                    
                    hasSufficientData = true;
                    
                    // Calculate Pearson correlation
                    let sumSensor = 0, sumRain = 0, sumSensorSquared = 0, sumRainSquared = 0, sumProd = 0;
                    const n = matchedData.sensor.length;
                    
                    for (let i = 0; i < n; i++) {
                        sumSensor += matchedData.sensor[i];
                        sumRain += matchedData.rainfall[i];
                        sumSensorSquared += matchedData.sensor[i] * matchedData.sensor[i];
                        sumRainSquared += matchedData.rainfall[i] * matchedData.rainfall[i];
                        sumProd += matchedData.sensor[i] * matchedData.rainfall[i];
                    }
                    
                    const numerator = n * sumProd - sumSensor * sumRain;
                    const denominator = Math.sqrt((n * sumSensorSquared - sumSensor * sumSensor) * (n * sumRainSquared - sumRain * sumRain));
                    
                    const correlation = denominator !== 0 ? numerator / denominator : 0;
                    const correlationStrength = Math.abs(correlation);
                    let correlationClass = 'text-gray-600';
                    let correlationText = 'No correlation';
                    
                    if (correlationStrength >= 0.7) {
                        correlationClass = 'text-red-600 font-bold';
                        correlationText = 'Strong correlation';
                    } else if (correlationStrength >= 0.5) {
                        correlationClass = 'text-orange-500 font-semibold';
                        correlationText = 'Moderate correlation';
                    } else if (correlationStrength >= 0.3) {
                        correlationClass = 'text-yellow-600';
                        correlationText = 'Weak correlation';
                    }
                    
                    correlationHTML += `
                        <div class="mb-3">
                            <p><strong>${sensorName}:</strong> Correlation coefficient = <span class="${correlationClass}">${correlation.toFixed(4)}</span></p>
                            <p>Interpretation: <span class="${correlationClass}">${correlationText}</span> (${correlation < 0 ? 'negative' : 'positive'})</p>
                            <p>Based on ${n} matching data points</p>
                        </div>
                    `;
                    
                    // Create a scatter plot for this sensor
                    const correlationPlotId = `correlation-plot-${sensorName}`;
                    let correlationPlotElement = document.getElementById(correlationPlotId);
                    
                    if (!correlationPlotElement) {
                        correlationPlotElement = document.createElement('div');
                        correlationPlotElement.id = correlationPlotId;
                        correlationPlotElement.className = 'mb-4 h-64';
                        correlationInfo.appendChild(correlationPlotElement);
                    }
                    
                    const trace = {
                        x: matchedData.rainfall,
                        y: matchedData.sensor,
                        mode: 'markers',
                        type: 'scatter',
                        name: sensorName,
                        marker: {
                            size: 10,
                            color: sensorName === 'X' ? 'rgb(0, 0, 255)' : 
                                   sensorName === 'Y' ? 'rgb(255, 0, 0)' : 'rgb(0, 128, 0)',
                            opacity: 0.7
                        }
                    };
                    
                    const layout = {
                        title: `${sensorName} vs Rainfall Correlation`,
                        xaxis: {
                            title: 'Rainfall (mm)'
                        },
                        yaxis: {
                            title: sensorName
                        },
                        margin: { t: 40, r: 40, b: 60, l: 60 }
                    };
                    
                    Plotly.newPlot(correlationPlotElement, [trace], layout);
                }
                
                if (!hasSufficientData) {
                    correlationHTML += `<p class="text-red-600">No sensors had sufficient matching data points with rainfall for reliable correlation.</p>`;
                }
                
                // Set the correlation info HTML
                correlationInfo.innerHTML = correlationHTML;
            }
            
            // Update UI based on file selection
            function updateUI() {
                const hasFile = window.uploadedData !== null && window.uploadedData.plot_data !== null;
                if (fileInput && postcodeInput && fetchRainfallBtn) {
                    // Update UI elements based on whether a file is uploaded
                    postcodeInput.disabled = !hasFile;
                    fetchRainfallBtn.disabled = !hasFile;
                    
                    // Clear rainfall data if no file is uploaded
                    if (!hasFile) {
                        window.rainfallData = null;
                        if (rainfallStatus) rainfallStatus.innerHTML = '';
                        // Reset the graph to remove rainfall data
                        if (window.uploadedData && window.uploadedData.plot_data) {
                            updateGraphWithRainfall();
                        }
                    } else {
                        // Enable the postcode input and fetch button
                        postcodeInput.disabled = false;
                        fetchRainfallBtn.disabled = false;
                        if (rainfallStatus) rainfallStatus.innerHTML = '<span class="text-gray-600">Enter a UK postcode to fetch rainfall data</span>';
                    }
                }
            }
        }

        // Test server connection
        function testServer() {
            try {
                axios.get('/test').then(response => {
                    console.log('Server is working! Response:', response.data);
                }).catch(error => {
                    console.error('Server connection error:', error);
                });
            } catch (error) {
                console.error('Error testing server:', error);
            }
        }

        function runSeasonalAnalysis(data) {
            const analysis = data.analysis;
            const plotData = data.plot_data;
            
            // Update movement metrics
            document.getElementById('movement-type').textContent = analysis.movement_type;
            document.getElementById('seasonal-strength').textContent = 
                (analysis.seasonal_strength * 100).toFixed(1) + '%';
            document.getElementById('trend-slope').textContent = 
                analysis.slope.toFixed(4) + ' mm/month';
            document.getElementById('trend-confidence').textContent = 
                (analysis.r_squared * 100).toFixed(1) + '%';
            document.getElementById('summer-avg').textContent = 
                analysis.summer_avg.toFixed(2) + ' mm';
            document.getElementById('winter-avg').textContent = 
                analysis.winter_avg.toFixed(2) + ' mm';
            
            // Create seasonal decomposition plot
            const dates = plotData.time;
            const values = plotData.values;
            
            const trace = {
                x: dates,
                y: values,
                type: 'scatter',
                mode: 'lines',
                name: 'Movement'
            };
            
            const layout = {
                title: 'Seasonal Movement Pattern',
                xaxis: { title: 'Date' },
                yaxis: { title: 'Movement (mm)' }
            };
            
            Plotly.newPlot('seasonal-plot', [trace], layout);
        }

        async function runAdvancedAnalysis() {
            const advancedGraphContainer = document.getElementById('advanced-graph-container');
            const patternAnalysisInfo = document.getElementById('pattern-analysis-info');
            const anomalyInfo = document.getElementById('anomaly-info');
            
            try {
                // Show loading state
                advancedGraphContainer.innerHTML = '<div class="p-4 bg-blue-50 rounded-lg"><p class="text-center text-blue-600">Running advanced analysis...</p></div>';
                
                // Get the first sensor's data
                const sensorData = window.uploadedData.plot_data[Object.keys(window.uploadedData.plot_data)[0]];
                
                // Send data for advanced analysis
                const response = await axios.post('/timeseries-analysis', {
                    data: sensorData.values
                });
                
                const result = response.data;
                
                // Create advanced analysis plot
                const trace = {
                    x: sensorData.time,
                    y: sensorData.values,
                    type: 'scatter',
                    name: 'Sensor Data',
                    line: {color: 'blue'}
                };
                
                const layout = {
                    title: 'Advanced Analysis',
                    xaxis: {title: 'Time'},
                    yaxis: {title: 'Movement'},
                    showlegend: true
                };
                
                Plotly.newPlot(advancedGraphContainer, [trace], layout);
                
                // Update pattern analysis info
                patternAnalysisInfo.innerHTML = `
                    <p><strong>Pattern Type:</strong> ${result.patterns}</p>
                    <p><strong>Repeating Patterns:</strong> ${result.motifs}</p>
                    <p><strong>Shape Classification:</strong> ${result.shape_classification}</p>
                `;
                
                // Update anomaly info
                anomalyInfo.innerHTML = `
                    <p><strong>Anomalies Detected:</strong> ${result.anomalies}</p>
                `;
                
            } catch (error) {
                console.error('Advanced analysis error:', error);
                advancedGraphContainer.innerHTML = `<div class="p-4 bg-red-50 rounded-lg"><p class="text-center text-red-600">Error: ${error.message}</p></div>`;
            }
        }
    </script>
</body>
</html> 